function solution(tickets, roll, shop, money) {
    // 티켓 정보를 객체로 파싱
    const ticketInfo = Object.fromEntries(tickets.map(t => {
        const [name, price] = t.split(' ');
        return [name, parseInt(price)];
    }));
    let dp = new Array(money + 1).fill(0);

    console.log(dp, '---dp---')

    const memo = new Map();

    function dfs(shopIndex, remainingMoney, ticketCounts) {
        // 모든 상점을 다 방문했는지 확인
        if (shopIndex >= shop.length) {
            // 모든 상점을 다 방문한 경우, 현재까지 모은 티켓들로 몇 개의 금 티켓을 만들 수 있는지 계산합니다.
            return Object.values(ticketCounts).reduce((sum, count) => sum + Math.floor(count / 3), 0);
        }
    
        // 현재 상태를 키로 메모이제이션 맵에서 결과를 찾아봅니다.
        const key = `${shopIndex},${remainingMoney},${JSON.stringify(ticketCounts)}`;
        if (memo.has(key)) return memo.get(key);
    
        let maxGoldTickets = 0; // 최대 금 티켓 개수를 저장할 변수
        const currentShop = shop[shopIndex]; // 현재 상점의 티켓 목록
        const combinations = 1 << currentShop.length; // 현재 상점에서 구매할 수 있는 모든 티켓 조합의 수
    
        // 모든 티켓 구매 조합을 탐색합니다.
        for (let mask = 0; mask < combinations; mask++) {
            let cost = 0; // 현재 조합의 총 비용
            const newTicketCounts = {...ticketCounts}; // 현재 티켓 개수를 복사
    
            for (let i = 0; i < currentShop.length; i++) {
                if (mask & (1 << i)) { // 비트마스크를 사용하여 조합을 확인
                    const ticket = currentShop[i];
                    cost += ticketInfo[ticket]; // 비용을 더합니다.
                    newTicketCounts[ticket] = (newTicketCounts[ticket] || 0) + 1; // 티켓 개수를 증가
                }
            }
    
            // 현재 조합의 비용이 남은 돈보다 적거나 같은 경우
            
            if (cost <= remainingMoney) {
                const nextMoney = remainingMoney - cost;
                // 다음 상점으로 이동할 수 있는 경우, 재귀 호출
                const goldTickets = shopIndex < shop.length - 1 && nextMoney >= roll
                    ? dfs(shopIndex + 1, nextMoney - roll, newTicketCounts)
                    : Object.values(newTicketCounts).reduce((sum, count) => sum + Math.floor(count / 3), 0);
    
                maxGoldTickets = Math.max(maxGoldTickets, goldTickets); // 최대 금 티켓 개수를 갱신
            }
        }
    
        // 현재 상점을 건너뛸 경우를 고려
        if (shopIndex < shop.length - 1 && remainingMoney >= roll) {
            maxGoldTickets = Math.max(maxGoldTickets, dfs(shopIndex + 1, remainingMoney - roll, ticketCounts));
        }
    
        // 현재 상태를 메모이제이션 맵에 저장
        memo.set(key, maxGoldTickets);
        return maxGoldTickets;
    }
    

    return dfs(0, money, {});
}


// 예제 사용법
let examples = [
  { tickets: ["A 1", "B 2", "C 5", "D 3"], roll: 10, shop: [["B", "C", "B", "C"], ["A", "A", "A", "B"], ["D", "D", "C", "D"]], money: 30 },
  { tickets: ["A 1", "B 2", "C 5", "D 3"], roll: 10, shop: [["B", "C", "B", "C"], ["A", "A", "A", "B"], ["D", "D", "C", "D"]], money: 100 },
  { tickets: ["A 1", "B 4", "C 3", "D 2"], roll: 2, shop: [["B", "C", "B", "C"], ["B", "C", "A"], ["D", "D", "C", "D"], ["B", "A", "A"]], money: 9 },
  { tickets: ["A 2", "B 1"], roll: 1, shop: [["A", "A", "A"], ["A", "B", "B"], ["A", "B", "B"], ["A", "B", "B"]], money: 9 },
  { tickets: ["A 2", "B 1"], roll: 5, shop: [["A", "A", "A"], ["A", "B", "B"], ["A", "B", "B"], ["A", "B", "B"]], money: 19 },
];

for (let example of examples) {
  console.log(solution(example.tickets, example.roll, example.shop, example.money));
}

/**
 * 문제 설명
 */
// 당신은 TFT(Ticket Finding Tactics)라는 게임을 플레이하고 있습니다. 이 게임은 주어진 자금으로 황금 티켓을 최대한 많이 모으는 것이 목표입니다.
// 당신이 이 게임에서 할 수 있는 행동은 다음과 같습니다.
// 1. 상점에서 일반 티켓 구매하기
// 2. 상점 새로고침하기
// 3. 동일한 일반 티켓 3개를 황금 티켓 1개로 교환하기
// 상점에는 일반 티켓 m개가 진열되어 있습니다. 당신은 티켓의 가격을 지불하여 진영되어있는 티켓 중 원하는 티켓을 구매할 수 있습니다. 또, 일정금액을 상점에 지불하고 상점을 최대 n - 1번 새로고침 할 수 있습니다. 새로고침이란, 상점에 진열 중이던 티켓을 모두 폐기하고 새로운 일반티켓 m개를 진열하는 행동입니다.

// 당신은 상점에 진열되는 티켓의 패턴을 분석하여 상점을 새로고침 했을 때 매번 어떤 티켓이 진열될지 예측하는데 성공했습니다. 당신은 예측한 결과를 바탕으로 황금 티켓을 가장 많이 모을 수 있는 방법으로 자금을 사용하려 합니다.

// 다음은 상점에서 티켓을 구매하여 황금 티켓을 모으는 예시입니다.
// <일반 티켓의 종류>
// [{티켓이름:A 가격: 1}, {티켓이름:B 가격: 2}, {티켓이름:C 가격: 5}, {티켓이름:D 가격: 3}]
// <상점의 티켓 진열 예측>
// [{상점순서: 최초 상점, 진열 티켓: B, C, B, C}, {상점순서: 두 번째 상점, 진열 티켓: A, A, A, B}, {상점순서: 세 번째 상점, 진열 티켓: D, D, C, D}]
// 일반 티켓의 종류와 상점의 티켓 진열 패턴이 위 푝와 같고, 상점 새로고침에 필요한 금액이 10, 당신에게 주어진 자금이 30이라고 가정해 보겠습니다. 최초 상점에서 "B" 2개를 구매하고, 새로고침 한 뒤, 두 번째 상점에서 "A" 3개, "B" 1개를 구매하면 총 2 x 2 + 10 + 1 x 3 + 2 x 1 = 19 만큼 자금을 사용해 "A"3개 "B" 3개를 구매할 수 있습니다. "A" 3개, "B" 3개를 황금 티켓 2개로 교환할 수 있으며, 이보다 더 많은 황금 티켓을 모으는 방법은 없습니다.

// 게임에 등장하는 모든 일반 티켓의 정보가 담긴 문자열 배열 tickets, 상점 새로고침에 필요한 금액을 나타내는 정수 roll, 상점의 새로고침 예측이 담긴 2차원 문자열 배열 shop과 당신에게 주어진 자금을 나타내는 정수 money가 매개변수로 주어집니다. 이때 모을 수 있는 황금 티켓 개수의 최댓값을 return 하도록 solution함수를 완성해주세요. 사용언어는 javascript로 작성해주세요.

// 제한사항: 
// 1 <= tickets의 길이 <= 1,000
// tickets의 원소는 "TICKET_NAME TICKET_PRICE" 형태이다.
//   TICKET_NAME은 티켓의 이름을 나타내며, 알파벳 대문자로만 구성된 길이 1~10 사이의 문자열이다.
//   TICKET_PRICE는 티켓의 가격을 나타내며, 1~10000 사이의 숫자이다.
//   TICKET_NAME(티켓의 이름)이 중복된 입력은 주어지지 않는다.
// 1 <= roll <= 10,000
// 1 <= shop 의 길이 = n <= 1,000
//   shop[i]는 새로고침 i번 했을 때 상점에 진열되는 티켓들의 이름을 담고 있다.
//   0 <= i <= n -1
//   shop의 길이 이상 새로고침 할 수는 없다.
//   1 <= shop[i]의 길이 = m <= 100
//     ticekts에 나타난 티켓의 이름만 담겨있다.
// 1 <= money <= 100,000,000

// 입출력 예
// 입출력 1: {tickets: ["A 1", "B 2", "C 5", "D 3"], roll: 10, shop: [["B", "C", "B", "C"],["A", "A", "A", "B"],["D", "D", "C", "D"]], money: 30}
// 입출력 2: {tickets: ["A 1", "B 2", "C 5", "D 3"], roll: 10, shop: [["B", "C", "B", "C"],["A", "A", "A", "B"],["D", "D", "C", "D"]], money: 100}
// 입출력 3: {tickets: ["A 2", "B 1"], roll: 1, shop: [["A", "A", "A"],["A", "B", "B"],["A", "B", "B"],["A", "B", "B"]], money: 9}
// 입출력 4: {tickets: ["A 2", "B 1"], roll: 5, shop: [["A", "A", "A"],["A", "B", "B"],["A", "B", "B"],["A", "B", "B"]], money: 19}

// 입출력 예 설명 
// - 입출력 1 문제 예시와 같다.
// - 입출력 2 처음 주어지는 자금인 money가 두 번의 새로고침 비용과 모든 티켓 비용을 지불하고도 남을 만큼 충분하다. 따라서 상점에 등장하는 모든 티켓을 구매하면 황금티켓 4개를 모을 수 있다.
// - 입출력 3 다음과 같은 방법으로 황금티켓을 1개 모을 수 있다. 이보다 더 많은 황금티켓을 모으는 방법은 없다.
//   1. 첫 번째 상점에서 티켓을 구매하지 않고 새로고침 한다.
//   2. 두 번째 상점에서 "A" 1개를 구매하고 새로고침 한다.
//   3. 세 번째 상점에서 티켓을 구매하지 않고 새로고침 한다.
//   4. 네 번째 상점에서 "A" 2개를 구매한다.
//   5. "A" 일반티켓 3개를 황금 티켓 1개와 교환 가능하다.
// - 입출력 4 다음과 같은 방법으로 황금티켓을 2개 모을 수 있다. 이보다 더 많은 황금티켓을 모으는 방법은 없다.
//   1. 첫 번째 상점에서 티켓을 구매하지 않고 새로고침 한다.
//   2. 두 번째 상점에서 "B" 2개를 구매하고 새로고침 한다.
//   3. 세 번째 상점에서 "B" 2개를 구매하고 새로고침 한다.
//   4. 네 번째 상점에서 "B" 2개를 구매한다.
//   5. "B" 일반티켓 6개를 황금 티켓 2개와 교환 가능하다.
// - 입출력 5 다음과 같은 방법으로 2개의 황금티켓을 모을 수 있으며 이보다 더 많은 황금티켓을 모을 순 없다.
//   1. 첫 번째 상점에서 "A" 3개를 구매하고 새로고침 한다.
//   2. 두 번째 상점에서 "B" 2개를 구매하고 새로고침 한다.
//   3. 세 번째 상점에서 "B" 1개를 구매한다.
//   5. "A" 일반티켓 6개를 황금 티켓 2개와 교환 가능하다.

// 안녕하세요. 간단하게 회사소개와 제 소개를 드리겠습니다. 
// 혹시 저희 회사에 대해 아는 정보가 있으신가요?
// 우선 저는 ECF에서 백엔드 개발자로 업무를 하고있고요, 무신사같은 멀티 쇼핑몰 플랫폼입니다.
// 현재 당장에는 카페24를 통해서 서비스 되고있는데요, 자체개발의 필요성을 느껴서 외주사를 통해서 nest.js, react, mysql, aws를 통해서 이전작업이 되고있습니다.
// 거기에 저희는 nest.js와 aws, mysql 쪽을 관리하게 될거에요.
// 외주사가 100퍼센트 개발 완료후에 저희가 고도화라던지 수정작업을 하게될거라 진행도가 100%가 될때까지는 QA업무처럼 오류발생되는부분 체크해서 피드백을 하고있는데
// 아마 합류하게 될 시점에는 완료가 돼서 직접 코드를 작성하게 될 수도 있고 그때까지 미완료가 되어 있을수도 있습니다.
// 당장 개발해야할 큰 기획들은 없어서 저와 같이 필요한부분들 체크해서 기능개발하는 업무가 주가 될거에요.

// 00님 자기소개 부탁드립니다.
// 질문 리스트(비기술)
// 1. 이씨에프에 지원한 동기는 무엇인가요?
// 2. Java만 사용한걸로 확인되는데 Nest.js를 사용해본 경험이 있나요?
// 3. 최근 회사 퇴직 후 지금까지 어떤 일을 하셨는지 궁금합니다.
// 4. (재직중이신거 같은데) 이직 사유가 무엇인가요? 
// 싱글톤 디자인패턴에 대해 설명해주시고 사용예시를 들어서 설명해주세요.
// 정답: 싱글톤 디자인패턴의 예시로는 다크모드 설정이 있습니다. 다크모드 설정은 앱 전체에서 공유되어야 하므로 싱글톤으로 구현할 수 있습니다. 싱글톤은 객체를 하나만 생성하도록 하는 패턴으로, 메모리를 절약하고 객체의 일관성을 유지하기 위해 사용합니다. 싱글톤 패턴은 getInstance 메소드를 사용하여 객체를 생성하고, 객체가 이미 생성되어 있다면 기존 객체를 반환합니다.
// 질문 리스트(기술)
// 1. Nest.js에서 미들웨어와 인터셉터의 차이점에 대해 설명해주세요. 
// 정답: 미들웨어는 요청과 응답 사이에 실행되는 함수이고, 인터셉터는 컨트롤러의 메소드 실행 전후에 실행되는 함수입니다. 미들웨어는 특정한 라우트나 전역으로 설정할 수 있지만, 인터셉터는 컨트롤러에만 설정할 수 있습니다.

// 2. Nest.js에서 파이프와 필터의 차이점에 대해 설명해주세요.
// 정답: 파이프는 요청 데이터를 변환하거나 유효성 검사를 하는데 사용되고, 필터는 예외를 처리하는데 사용됩니다. 파이프는 라우트 핸들러 전에 실행되고, 필터는 라우트 핸들러 후에 실행됩니다.

// 3. Nest.js에서 가드가 어떤역할을 하는지 아는대로 설명해주세요.
// 정답: 가드는 요청을 처리하기 전에 실행되는 함수로, 특정 조건을 만족하지 않으면 요청을 거부합니다. 가드는 라우트 핸들러 전에 실행되며, 특정 조건을 만족하지 않으면 예외를 발생시킵니다.

// 4. Nest.js의 스코프에 대해 아는대로 설명해주세요. 스코프는 어떤 역할을 하는지 설명해주세요.
// 정답: Nest.js의 스코프는 모듈, 컨트롤러, 서비스, 미들웨어, 파이프, 필터, 가드, 인터셉터 등의 요소를 정의하는데 사용됩니다. 스코프는 의존성 주입을 위한 컨테이너 역할을 하며, 모듈은 스코프를 정의하는 단위입니다.

// 5. 의존성주입(DI)에 대해 아는대로 설명해주세요. 왜 DI를 사용하는지에 대해 설명해주세요. 
// 정답: 의존성 주입은 객체 간의 결합도를 낮추기 위해 사용합니다. 객체 간의 결합도를 낮추면 코드의 재사용성이 높아지고 유지보수가 쉬워집니다.

// 6. IoC(Inversion of Control)에 대해 아는대로 설명해주세요. 왜 IoC를 사용하는지에 대해 설명해주세요.
// 정답: IoC는 제어의 역전을 의미하며, 객체의 생성과 생명주기를 외부에서 관리하는 것을 말합니다. IoC를 사용하면 객체 간의 결합도를 낮출 수 있고, 코드의 재사용성과 유지보수성을 높일 수 있습니다.

// 7. TypeScript에서 제네릭에 대해 아는데로 설명해주세요. 
// 정답: 제네릭은 타입을 파라미터로 받아서 사용하는 기능으로, 함수나 클래스를 정의할 때 타입을 동적으로 지정할 수 있습니다. 제네릭을 사용하면 코드의 재사용성을 높일 수 있습니다.

// 8. TCP/IP의 동작방식에 대해 아는대로 설명해주세요.
// 정답: TCP/IP는 인터넷 프로토콜 스위트로, TCP(Transmission Control Protocol)와 IP(Internet Protocol)로 구성되어 있습니다. TCP는 신뢰성 있는 데이터 전송을 담당하고, IP는 데이터의 경로를 결정하는 역할을 합니다.

// 9. RDBMS 관계형 데이터베이스에서 Index가 어떤 역할을 하는지 아는대로 설명해주세요.
// 정답: Index는 데이터베이스의 검색 속도를 높이기 위해 사용되는 자료구조로, 특정 컬럼의 값을 키로 사용하여 데이터를 빠르게 검색할 수 있습니다.

// 10. Index의 자료구조인 B-Tree와 B+ Tree의 차이점에 대해 설명해주세요.
// 정답: B-Tree는 키와 데이터를 모두 저장하는 반면, B+ Tree는 키만 저장하고 데이터는 리프 노드에만 저장합니다. B+ Tree는 범위 검색에 효율적이고, 더 많은 키를 저장할 수 있습니다.

// 11. DB 정규형에 대해 아는대로 설명해주세요.
// 정답: DB 정규형은 데이터베이스의 설계 중복을 줄이고 데이터의 일관성을 유지하기 위해 사용하는 개념입니다. 1NF는 모든 속성이 원자값을 가지도록, 2NF는 기본키에 완전 함수 종속되도록, 3NF는 이행적 함수 종속을 제거하도록 설계합니다.

// 12. DB 1~3정규형에 대해 설명해주세요.
// 정답: 1NF는 모든 속성이 원자값을 가지도록, 2NF는 기본키에 완전 함수 종속되도록, 3NF는 이행적 함수 종속을 제거하도록 설계합니다.

// 13. DB 트랜잭션이 무엇인지 아는대로 설명해주세요.
// 정답: DB 트랜잭션은 데이터베이스의 상태를 변화시키는 작업의 단위로, ACID(원자성, 일관성, 고립성, 지속성)를 보장합니다. 트랜잭션은 모두 성공하거나 모두 실패해야 하며, 중간에 실패하면 롤백되어야 합니다.

// 14. REST API가 각광받는 이유에 대해 설명해주세요.
// 정답: REST API는 HTTP 프로토콜을 사용하여 데이터를 주고받는 API로, 간단하고 표준화된 인터페이스를 제공하기 때문에 각광받습니다. REST API는 HTTP 메소드를 사용하여 CRUD(Create, Read, Update, Delete) 기능을 제공하며, URI를 사용하여 자원을 표현합니다.

// 15. TypeORM을 사용하는 이유가 대해 설명해주세요.
// 정답: TypeORM은 TypeScript로 작성된 ORM(Object-Relational Mapping) 라이브러리로, 데이터베이스와의 연동을 쉽게 할 수 있습니다. TypeORM을 사용하면 SQL 쿼리를 직접 작성하지 않아도 되고, TypeScript의 타입 시스템을 활용할 수 있습니다.

// 16. 객체지향 프로그래밍에 대해 아는대로 설명해주세요.
// 정답: 객체지향 프로그래밍은 객체를 중심으로 프로그래밍하는 패러다임으로, 클래스와 객체를 사용하여 데이터와 기능을 하나로 묶어서 관리합니다. 객체지향 프로그래밍은 상속, 캡슐화, 다형성을 지원하며, 코드의 재사용성을 높일 수 있습니다.

// 17. TypeScript에서 인터페이스와 클래스의 차이점을 설명해주세요.
// 정답: 인터페이스는 타입을 정의하는 역할을 하며, 클래스는 객체를 생성하는 역할을 합니다. 인터페이스는 타입만 정의할 수 있지만, 클래스는 타입과 생성자, 메소드, 속성을 정의할 수 있습니다.

// 18. 알고있는 디자인패턴에 대해 하나만 설명해주시고 왜 그 디자인패턴을 사용하는지에 대해 설명해주세요.
// 정답: 예)싱글톤 디자인 패턴은 객체를 하나만 생성하도록 하는 패턴으로, 메모리를 절약하고 객체의 일관성을 유지하기 위해 사용합니다. 싱글톤 패턴은 전역 상태를 관리할 때 유용하며, 객체의 생성과 생명주기를 외부에서 관리할 수 있습니다.

// 19. 코딩테스트(2번문제)풀이 시 어려웠던 점과 해결방법에 대해 설명해주세요.
// 정답: 예)TFT 문제 풀이 시 어려웠던 점은 상점의 티켓 진열 패턴을 어떻게 분석할지였습니다. 상점의 티켓 진열 패턴을 분석하기 위해 비트마스크를 사용하여 모든 티켓 구매 조합을 탐색하였고, 메모이제이션을 사용하여 중복 계산을 피했습니다.

// 20. 메모이제이션이 무엇이고 어떤 경우에 사용하는지 설명해주세요.
// 정답: 메모이제이션은 이전에 계산한 값을 저장하여 중복 계산을 피하는 기법으로, 동적 계획법 알고리즘에서 사용됩니다. 메모이제이션을 사용하면 중복 계산을 피할 수 있고, 실행 시간을 단축할 수 있습니다.

// 21. 비트마스크가 무엇이고 어떤 경우에 사용하는지 설명해주세요.
// 정답: 비트마스크는 이진수를 사용하여 집합을 표현하는 기법으로, 집합 연산을 빠르게 수행할 수 있습니다. 비트마스크를 사용하면 집합 연산을 빠르게 수행할 수 있고, 메모리를 절약할 수 있습니다.

// 22. DFS(깊이 우선 탐색)와 BFS(너비 우선 탐색)의 차이점에 대해 설명해주세요.
// 정답: DFS는 스택을 사용하여 깊이 우선 탐색을 수행하는 알고리즘으로, BFS는 큐를 사용하여 너비 우선 탐색을 수행하는 알고리즘입니다. DFS는 재귀 함수를 사용하여 구현할 수 있고, BFS는 큐를 사용하여 구현할 수 있습니다.

// 23. 웹소켓이 무엇이고 어떤 경우에 사용하는지 설명해주세요. 질문 레벨 1~5 중 이 질문은 
// 정답: 웹소켓은 실시간 양방향 통신을 제공하는 프로토콜로, HTTP 프로토콜의 단점을 보완하기 위해 사용됩니다. 웹소켓은 실시간 채팅, 온라인 게임, 주식 시세 등 실시간 데이터를 전송하는데 사용됩니다.